# -*- coding: utf-8 -*-

"""
    uberapilib.controllers.api_controller

    This file was automatically generated by APIMATIC BETA v2.0 on 12/13/2016
"""

from .base_controller import *
from ..models.request_map_response import RequestMapResponse
from ..models.request_details_collections import RequestDetailsCollections
from ..models.user_profile import UserProfile
from ..models.product_collection import ProductCollection
from ..models.price_estimate_collection import PriceEstimateCollection
from ..models.time_estimate_collection import TimeEstimateCollection
from ..models.user_activity import UserActivity
from ..models.promotions_response import PromotionsResponse
from ..models.request import Request
from ..models.product import Product

class APIController(BaseController):

    """A Controller to access Endpoints in the uberapilib API."""
    

    def get_request_map(self,
                        request_id):
        """Does a GET request to /v1/requests/{request_id}/map.

        Get a map with a visual representation of a Request.

        Args:
            request_id (string): Unique identifier representing a Request.

        Returns:
            RequestMapResponse: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/requests/{request_id}/map'
        _query_builder = APIHelper.append_url_with_template_parameters(_query_builder, { 
            'request_id': request_id
        })
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request.', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', _context)
        elif _context.response.status_code == 409:
            raise APIException('409 - A conflict needs to be resolved before the request can be made.', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited.', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error.', _context)
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, RequestMapResponse.from_dictionary)

    def delete_request_cancel(self,
                              request_id):
        """Does a DELETE request to /v1/requests/{request_id}.

        Cancel an ongoing Request on behalf of a rider.

        Args:
            request_id (string): Unique identifier representing a Request.

        Returns:
            void: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/requests/{request_id}'
        _query_builder = APIHelper.append_url_with_template_parameters(_query_builder, { 
            'request_id': request_id
        })
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare and execute request
        _request = self.http_client.delete(_query_url)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request.', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', _context)
        elif _context.response.status_code == 409:
            raise APIException('409 - A conflict needs to be resolved before the request can be made', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited.', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error', _context)
        self.validate_response(_context)    

    def get_request_details(self,
                            request_id):
        """Does a GET request to /v1/requests/{request_id}.

        Get the real time status of an ongoing trip that was created using the
        Ride Request endpoint.

        Args:
            request_id (string): TODO: type description here. Example: 

        Returns:
            RequestDetailsCollections: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/requests/{request_id}'
        _query_builder = APIHelper.append_url_with_template_parameters(_query_builder, { 
            'request_id': request_id
        })
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request.', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found.', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', _context)
        elif _context.response.status_code == 409:
            raise APIException('409 - A conflict needs to be resolved before the request can be made.', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited.', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error', _context)
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, RequestDetailsCollections.from_dictionary)

    def get_user_profile(self):
        """Does a GET request to /v1/me.

        The User Profile endpoint returns information about the Uber user that
        has authorized with the application.

        Returns:
            UserProfile: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/me'
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request.', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found.', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited.', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error.', _context)
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, UserProfile.from_dictionary)

    def get_products_types(self,
                           options=dict()):
        """Does a GET request to /v1/products.

        The Products endpoint returns information about the Uber products
        offered at a given location. The response includes the display name
        and other details about each product, and lists the products in the
        proper display order.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    latitude -- float -- Latitude component of location.
                    longitude -- float -- Longitude component of location.

        Returns:
            ProductCollection: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/products'
        _query_url = APIHelper.clean_url(_query_builder)
        _query_parameters = {
            'latitude': options.get('latitude', None),
            'longitude': options.get('longitude', None)
        }

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request.', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found.', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited.', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error.', _context)
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, ProductCollection.from_dictionary)

    def get_price_estimates(self,
                            options=dict()):
        """Does a GET request to /v1/estimates/price.

        The Price Estimates endpoint returns an estimated price range for each
        product offered at a given location. The price estimate is provided as
        a formatted string with the full price range and the localized
        currency symbol.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    end_latitude -- float -- Latitude component of end
                        location.
                    end_longitude -- float -- Longitude component of end
                        location.
                    start_latitude -- float -- Latitude component of start
                        location.
                    start_longitude -- float -- Longitude component of start
                        location.

        Returns:
            PriceEstimateCollection: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/estimates/price'
        _query_url = APIHelper.clean_url(_query_builder)
        _query_parameters = {
            'end_latitude': options.get('end_latitude', None),
            'end_longitude': options.get('end_longitude', None),
            'start_latitude': options.get('start_latitude', None),
            'start_longitude': options.get('start_longitude', None)
        }

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request.', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found.', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited.', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error.', _context)
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, PriceEstimateCollection.from_dictionary)

    def get_time_estimates(self,
                           options=dict()):
        """Does a GET request to /v1/estimates/time.

        The Time Estimates endpoint returns ETAs for all products offered at a
        given location, with the responses expressed as integers in seconds.
        We recommend that this endpoint be called every minute to provide the
        most accurate, up-to-date ETAs.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    start_latitude -- float -- Latitude component of the start
                        location
                    start_longitude -- float -- Longitude component of the
                        start location
                    customer_uuid -- string -- The customer id interested in
                        estimate
                    product_id -- string -- Id of the requested product

        Returns:
            TimeEstimateCollection: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/estimates/time'
        _query_url = APIHelper.clean_url(_query_builder)
        _query_parameters = {
            'start_latitude': options.get('start_latitude', None),
            'start_longitude': options.get('start_longitude', None),
            'customer_uuid': options.get('customer_uuid', None),
            'product_id': options.get('product_id', None)
        }

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request.', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found.', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited.', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error.', _context)
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, TimeEstimateCollection.from_dictionary)

    def get_user_activity_v_1_1(self,
                                options=dict()):
        """Does a GET request to /v1.1/history.

        The User Activity endpoint returns data about a user's lifetime
        activity with Uber. The response will include pickup locations and
        times, dropoff locations and times, the distance of past requests, and
        information about which products were requested.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    limit -- int -- Number of items to return for pagging
                    offset -- int -- Page offset for pagging

        Returns:
            UserActivity: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1.1/history'
        _query_url = APIHelper.clean_url(_query_builder)
        _query_parameters = {
            'limit': options.get('limit', None),
            'offset': options.get('offset', None)
        }

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request.', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found.', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited.', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error.', _context)
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, UserActivity.from_dictionary)

    def get_promotions(self,
                       options=dict()):
        """Does a GET request to /v1/promotions.

        The Promotions endpoint returns information about the promotion that
        will be available to a new user based on their activity's location.
        These promotions do not apply for existing users.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    end_latitude -- float -- Latitude component of end
                        location.
                    end_longitude -- float -- Longitude component of end
                        location.
                    start_latitude -- float -- Latitude component of start
                        location.
                    start_longitude -- float -- Longitude component of start
                        location

        Returns:
            PromotionsResponse: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/promotions'
        _query_url = APIHelper.clean_url(_query_builder)
        _query_parameters = {
            'end_latitude': options.get('end_latitude', None),
            'end_longitude': options.get('end_longitude', None),
            'start_latitude': options.get('start_latitude', None),
            'start_longitude': options.get('start_longitude', None)
        }

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request.', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found.', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', _context)
        elif _context.response.status_code == 409:
            raise APIException('409 - A conflict needs to be resolved before the request can be made.', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error.', _context)
        elif _context.response.status_code == 222:
            raise APIException('222 - bac', _context)
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, PromotionsResponse.from_dictionary)

    def create_request(self,
                       body):
        """Does a POST request to /v1/requests.

        The Request endpoint allows a ride to be requested on behalf of an
        Uber user given their desired product, start, and end locations.
        Please review the Sandbox documentation on how to develop and test
        against these endpoints without making real-world Requests and being
        charged.

        Args:
            body (RequestBody): TODO: type description here. Example: 

        Returns:
            Request: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/requests'
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json',
            'content-type': 'application/json; charset=utf-8'
        }

        # Prepare and execute request
        _request = self.http_client.post(_query_url, headers=_headers, parameters=APIHelper.json_serialize(body))
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise APIException('400 - Malformed request', _context)
        elif _context.response.status_code == 401:
            raise APIException('401 - Unauthorized the request requires user authentication (not logged in).', _context)
        elif _context.response.status_code == 403:
            raise APIException('403 - Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context)
        elif _context.response.status_code == 404:
            raise APIException('404 - Not found', _context)
        elif _context.response.status_code == 406:
            raise APIException('406 - Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json', _context)
        elif _context.response.status_code == 409:
            raise APIException('409 - A conflict needs to be resolved before the request can be made.', _context)
        elif _context.response.status_code == 422:
            raise APIException('422 - Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', _context)
        elif _context.response.status_code == 429:
            raise APIException('429 - Too Many Requests. Rate limited.', _context)
        elif _context.response.status_code == 500:
            raise APIException('500 - Internal Server Error.', _context)
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, Request.from_dictionary)

    def get_product_detail_by_id(self,
                                 product_id):
        """Does a GET request to /v1/products/{product_id}.

        Get product details w.r.t id

        Args:
            product_id (string): Unique identifier representing a specific
                product for a given latitude & longitude. For example, uberX
                in San Francisco will have a different product_id than uberX
                in Los Angeles.

        Returns:
            Product: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _query_builder = Configuration.base_uri
        _query_builder += '/v1/products/{product_id}'
        _query_builder = APIHelper.append_url_with_template_parameters(_query_builder, { 
            'product_id': product_id
        })
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        BasicAuth.apply(_request)
        _context = self.execute_request(_request)        
        self.validate_response(_context)    

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, Product.from_dictionary)
